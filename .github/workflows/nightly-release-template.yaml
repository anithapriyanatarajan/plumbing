name: 'Nightly Release Template'

on:
  workflow_call:
    inputs:
      project-name:
        description: 'Name of the project to release (e.g., pipeline, triggers, dashboard)'
        required: true
        type: string
      git-repository:
        description: 'Git repository URL (without https://)'
        required: true
        type: string
      container-registry:
        description: 'Container registry URL'
        required: false
        type: string
        default: 'ghcr.io'
      registry-namespace:
        description: 'Registry namespace/path'
        required: true
        type: string
      run-tests:
        description: 'Run integration tests before release'
        required: false
        type: boolean
        default: false
      kubernetes-version:
        description: 'Kubernetes version for testing'
        required: false
        type: string
        default: 'v1.31.0'
      enable-chains:
        description: 'Enable Tekton Chains for supply chain security'
        required: false
        type: boolean
        default: true
    outputs:
      release-version:
        description: 'Generated release version'
        value: ${{ jobs.release.outputs.release-version }}
      release-sha:
        description: 'Git SHA of the release'
        value: ${{ jobs.release.outputs.release-sha }}
      release-url:
        description: 'URL to release artifacts'
        value: ${{ jobs.release.outputs.release-url }}
    secrets:
      GH_TOKEN:
        description: 'GitHub token for repository access'
        required: true
      REGISTRY_TOKEN:
        description: 'Container registry authentication token'
        required: true

permissions:
  contents: read
  packages: write
  id-token: write  # For OIDC token generation
  attestations: write  # For GitHub attestations

env:
  REGISTRY_URL: ${{ inputs.container-registry }}
  REGISTRY_NAMESPACE: ${{ inputs.registry-namespace }}

jobs:
  release:
    name: 'Release ${{ inputs.project-name }}'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      release-version: ${{ steps.metadata.outputs.version }}
      release-sha: ${{ steps.metadata.outputs.sha }}
      release-url: ${{ steps.metadata.outputs.url }}
    
    steps:
      - name: Checkout source repository
        uses: actions/checkout@v4
        with:
          repository: tektoncd/${{ inputs.project-name }}
          token: ${{ secrets.GH_TOKEN }}
          fetch-depth: 0  # Full history for proper versioning
          path: ${{ inputs.project-name }}

      - name: Show current working directory
        run: |
          echo "Current working directory: $(pwd)"
          
      - name: Checkout plumbing for actions
        uses: actions/checkout@v4
        with:
          path: plumbing

      - name: Show current working directory
        run: |
          echo "Current working directory: $(pwd)"

      - name: Setup Tekton environment
        id: tekton
        uses: ./plumbing/.github/actions/setup-kind
        with:
          kubernetes-version: ${{ inputs.kubernetes-version }}
          registry-url: ${{ inputs.container-registry }}
          enable-chains: ${{ inputs.enable-chains }}
          cluster-name: ${{ inputs.project-name }}-release
          
      - name: Setup container registry authentication
        env:
          REGISTRY_TOKEN: ${{ secrets.REGISTRY_TOKEN }}
          CONTAINER_REGISTRY: ${{ inputs.container-registry }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          echo "ðŸ” Configuring container registry authentication..."
          echo "$REGISTRY_TOKEN" | docker login "$CONTAINER_REGISTRY" -u "$GITHUB_ACTOR" --password-stdin

      - name: Show current working directory
        run: |
          echo "Current working directory: $(pwd)"
          ls -al

      - name: Generate release metadata
        id: metadata
        env:
          PROJECT_NAME: ${{ inputs.project-name }}
          CONTAINER_REGISTRY: ${{ inputs.container-registry }}
          REGISTRY_NAMESPACE: ${{ inputs.registry-namespace }}
        run: |
          pushd "$PROJECT_NAME"
          echo "ðŸ“‹ Generating release metadata..."
          # Get latest commit SHA
          GIT_SHA=$(git rev-parse HEAD)
          SHORT_SHA=$(echo $GIT_SHA | cut -c1-10)
          # Generate version tag
          VERSION_TAG="v$(date +"%Y%m%d")-${SHORT_SHA}"
          # Construct release URL
          RELEASE_URL="https://$CONTAINER_REGISTRY/$REGISTRY_NAMESPACE/$PROJECT_NAME"
          echo "version=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "sha=$GIT_SHA" >> $GITHUB_OUTPUT
          echo "short-sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "url=$RELEASE_URL" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Release metadata:"
          echo "  Project: $PROJECT_NAME"
          echo "  Version: $VERSION_TAG"
          echo "  SHA: $GIT_SHA"
          echo "  Registry: $RELEASE_URL"
          popd

      - name: Show current working directory
        run: |  
          echo "Current working directory: $(pwd)"

      - name: Install required tools
        run: |
          echo "ðŸ”§ Installing ko CLI..."
          curl -sL https://github.com/ko-build/ko/releases/latest/download/ko_$(uname -s)_$(uname -m).tar.gz | sudo tar -xz -C /usr/local/bin
          ko version

          echo "ðŸ”§ Installing kustomize..."
          KUSTOMIZE_VERSION=v5.4.1  # Change to desired version
          curl -sLo kustomize.tar.gz https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2F${KUSTOMIZE_VERSION}/kustomize_${KUSTOMIZE_VERSION}_linux_amd64.tar.gz
          tar -xzf kustomize.tar.gz
          chmod +x kustomize
          sudo mv kustomize /usr/local/bin/
          kustomize version

          echo "ðŸ“¦ Installing go-junit-report..."
          go install github.com/jstemmer/go-junit-report@latest
          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Run integration tests
        if: inputs.run-tests
        timeout-minutes: 30
        env:
          PROJECT_NAME: ${{ inputs.project-name }}
          KUBECONFIG_PATH: ${{ steps.tekton.outputs.kubeconfig-path }}
          KO_DOCKER_REPO: ${{ inputs.container-registry }}/${{ inputs.registry-namespace }}
        run: |
          pushd "$PROJECT_NAME"
          echo "Current working directory: $(pwd)"
          echo "ðŸ§ª Running integration tests for $PROJECT_NAME..."
          # Set up test environment to use existing cluster
          export KUBECONFIG="$KUBECONFIG_PATH"
          export KO_DOCKER_REPO="$KO_DOCKER_REPO"
          # Skip GCP cluster initialization since we're using existing cluster
          export SKIP_INITIALIZE=true
          export SYSTEM_NAMESPACE=tekton-pipelines
          # Run project-specific tests
          if [ -f "./test/e2e-tests.sh" ]; then
            echo "Running e2e tests (using existing cluster, skipping GCP initialization)..."
            ./test/e2e-tests.sh
          elif [ -f "./test/presubmit-tests.sh" ]; then
            echo "Running presubmit tests..."
            ./test/presubmit-tests.sh
          else
            echo "No standard test script found, running basic validation..."
            make test || echo "No make test target, skipping"
          fi
          echo "âœ… Integration tests completed successfully"
          popd

      - name: Show current working directory
        run: |
          echo "Current working directory: $(pwd)"

      - name: Build and publish release
        id: release
        timeout-minutes: 30
        env:
          PROJECT_NAME: ${{ inputs.project-name }}
          KUBECONFIG_PATH: ${{ steps.tekton.outputs.kubeconfig-path }}
          KO_DOCKER_REPO: ${{ inputs.container-registry }}/${{ inputs.registry-namespace }}
          TAG: ${{ steps.metadata.outputs.version }}
        run: |
          pushd "$PROJECT_NAME"
          echo "Current working directory: $(pwd)"
          echo "ðŸ—ï¸ Building and publishing release for $PROJECT_NAME..."
          # Set up build environment
          export KUBECONFIG="$KUBECONFIG_PATH"
          export KO_DOCKER_REPO="$KO_DOCKER_REPO"
          export TAG="$TAG"
          # Build release artifacts
          if [ -f "./hack/release.sh" ]; then
            echo "Using project release script..."
            ./hack/release.sh --tag=$TAG --output=release.yaml
          elif [ -f "./config" ] && [ -d "./config" ]; then
            echo "Using kustomize build..."
            kustomize build ./config/ > release.yaml
          else
            echo "âŒ No recognized build method found"
            exit 1
          fi
          # Verify release.yaml was created
          if [ ! -f "release.yaml" ]; then
            echo "âŒ release.yaml not found after build"
            exit 1
          fi
          echo "ðŸ“¦ Release artifacts generated:"
          ls -la *.yaml || true
          # Tag and push container images
          if command -v ko >/dev/null 2>&1; then
            echo "Publishing container images with ko..."
            ko publish --platform=linux/amd64,linux/arm64 --tags=$TAG ./cmd/...
          fi
          echo "âœ… Release build completed successfully"
          popd
          
      - name: Show current working directory
        run: |
          echo "Current working directory: $(pwd)"
          ls -al ./${{ inputs.project-name }}
          ls -al ./plumbing

      - name: Generate GitHub attestations
        if: inputs.enable-chains
        uses: actions/attest-build-provenance@v1
        with:
          subject-path: '${{ inputs.project-name }}/release.yaml'
          
      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: '${{ inputs.project-name }}-release-${{ steps.metadata.outputs.version }}'
          path: |
            release.yaml
            *.yaml
          retention-days: 90
          
      - name: Create release summary
        env:
          PROJECT_NAME: ${{ inputs.project-name }}
          VERSION: ${{ steps.metadata.outputs.version }}
          SHA: ${{ steps.metadata.outputs.sha }}
          REGISTRY_URL: ${{ steps.metadata.outputs.url }}
          RUN_TESTS: ${{ inputs.run-tests }}
          ENABLE_CHAINS: ${{ inputs.enable-chains }}
          CONTAINER_REGISTRY: ${{ inputs.container-registry }}
        run: |
          echo "# ðŸš€ Nightly Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“¦ Release Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Project**: $PROJECT_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "- **Git SHA**: \`$SHA\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: $REGISTRY_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests Run**: $RUN_TESTS" >> $GITHUB_STEP_SUMMARY
          echo "- **Chains Enabled**: $ENABLE_CHAINS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“‹ Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Release manifest: \`release.yaml\`" >> $GITHUB_STEP_SUMMARY
          echo "- Container images: Published to $CONTAINER_REGISTRY" >> $GITHUB_STEP_SUMMARY
          if [ "$ENABLE_CHAINS" = "true" ]; then
            echo "- Supply chain attestations: Generated" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Release completed successfully!" >> $GITHUB_STEP_SUMMARY
          
  cleanup:
    name: 'Cleanup'
    runs-on: ubuntu-latest
    needs: release
    if: always()
    steps:
      - name: Cleanup test environment
        run: |
          echo "ðŸ§¹ Cleaning up test environment..."
          # Cleanup is handled automatically by GitHub Actions runner reset
          echo "âœ… Cleanup completed" 